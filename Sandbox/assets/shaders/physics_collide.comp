#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct InstanceData
{
    vec4 tint_color;
    mat4 transform;
};

struct BodyGPU
{
    vec4 pos_invMass;        // xyz pos, w invMass
    vec4 vel_type;           // xyz vel, w type (float)
    vec4 halfExt_radius;     // xyz half extents, w radius
};

layout(std430, set = 0, binding = 0) buffer Bodies { BodyGPU b[]; } BodiesSSBO;
layout(std430, set = 1, binding = 0) buffer Instances { InstanceData inst[]; } InstSSBO;

layout(set = 2, binding = 0) uniform Params
{
    vec3 world_min; float dt;
    vec3 world_max; uint  body_count;
    float separation_slop;
    float push_strength;
    float damping;
    float _pad0;
} P;

uint collider_type(uint i) { return uint(BodiesSSBO.b[i].vel_type.w + 0.5); }

vec3  position(uint i) { return BodiesSSBO.b[i].pos_invMass.xyz; }
vec3  velocity(uint i) { return BodiesSSBO.b[i].vel_type.xyz; }
float invMass(uint i)  { return BodiesSSBO.b[i].pos_invMass.w; }
vec3  halfExt(uint i)  { return BodiesSSBO.b[i].halfExt_radius.xyz; }
float radius(uint i)   { return BodiesSSBO.b[i].halfExt_radius.w; }

void set_position(uint i, vec3 p) { BodiesSSBO.b[i].pos_invMass.xyz = p; }
void set_velocity(uint i, vec3 v) { BodiesSSBO.b[i].vel_type.xyz = v; }

vec3 resolve_aabb_aabb(vec3 aC, vec3 aE, vec3 bC, vec3 bE)
{
    vec3 d = aC - bC;
    vec3 o = (aE + bE) - abs(d);
    if (o.x <= 0.0 || o.y <= 0.0 || o.z <= 0.0) return vec3(0);

    if (o.x < o.y && o.x < o.z) return vec3(sign(d.x) * o.x, 0, 0);
    if (o.y < o.z)              return vec3(0, sign(d.y) * o.y, 0);
    return vec3(0, 0, sign(d.z) * o.z);
}

vec3 resolve_sphere_sphere(vec3 pa, float ra, vec3 pb, float rb)
{
    vec3 d = pa - pb;
    float dist2 = dot(d,d);
    float r = ra + rb;
    if (dist2 >= r*r) return vec3(0);

    float dist = sqrt(max(dist2, 1e-8));
    vec3 n = d / dist;
    float pen = (r - dist);
    return n * pen;
}

vec3 resolve_sphere_aabb(vec3 p, float r, vec3 c, vec3 e)
{
    vec3 q = clamp(p, c - e, c + e);
    vec3 d = p - q;
    float dist2 = dot(d,d);
    if (dist2 >= r*r) return vec3(0);

    float dist = sqrt(max(dist2, 1e-8));
    vec3 n = d / dist;
    float pen = (r - dist);
    return n * pen;
}

void contain(inout vec3 p, inout vec3 v, vec3 e, float r, uint type)
{
    vec3 margin = (type == 1u) ? e : vec3(r);
    vec3 minp = P.world_min + margin;
    vec3 maxp = P.world_max - margin;

    if (p.x < minp.x) { p.x = minp.x; v.x *= -0.5; }
    if (p.x > maxp.x) { p.x = maxp.x; v.x *= -0.5; }
    if (p.y < minp.y) { p.y = minp.y; v.y *= -0.5; }
    if (p.y > maxp.y) { p.y = maxp.y; v.y *= -0.5; }
    if (p.z < minp.z) { p.z = minp.z; v.z *= -0.5; }
    if (p.z > maxp.z) { p.z = maxp.z; v.z *= -0.5; }
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i >= P.body_count) return;

    uint ti = collider_type(i);
    float invMi = invMass(i);
    if (invMi == 0.0) return;

    vec3 pi = position(i);
    vec3 vi = velocity(i);

    // --- Integrate (GPU owns motion) ---
    vi += vec3(0.0, -9.81, 0.0) * P.dt;
    pi += vi * P.dt;

    vec3 corr = vec3(0);

    for (uint j = 0; j < P.body_count; ++j)
    {
        if (j == i) continue;

        uint tj = collider_type(j);
        vec3 pj = position(j);

        bool iSphere = (ti == 0u) || (ti == 2u);
        bool jSphere = (tj == 0u) || (tj == 2u);

        if (iSphere && jSphere)
        {
            vec3 push = resolve_sphere_sphere(pi, radius(i), pj, radius(j));
            if (length(push) > 0.0) corr += push;
        }
        else if (ti == 1u && tj == 1u)
        {
            vec3 push = resolve_aabb_aabb(pi, halfExt(i), pj, halfExt(j));
            if (length(push) > 0.0) corr += push;
        }
        else
        {
            if (iSphere && tj == 1u)
            {
                vec3 push = resolve_sphere_aabb(pi, radius(i), pj, halfExt(j));
                if (length(push) > 0.0) corr += push;
            }
            else if (ti == 1u && jSphere)
            {
                vec3 push = resolve_sphere_aabb(pj, radius(j), pi, halfExt(i));
                push = -push;
                if (length(push) > 0.0) corr += push;
            }
        }
    }

    float corrLen = length(corr);
    if (corrLen > 0.0)
    {
        vec3 n = corr / corrLen;
        float pen = max(corrLen - P.separation_slop, 0.0);
        pi += n * (pen * P.push_strength);

        float vn = dot(vi, n);
        if (vn < 0.0) vi -= n * vn;
    }

    vi *= P.damping;
    contain(pi, vi, halfExt(i), radius(i), ti);

    set_position(i, pi);
    set_velocity(i, vi);

    InstSSBO.inst[i].transform = mat4(
        vec4(1,0,0,0),
        vec4(0,1,0,0),
        vec4(0,0,1,0),
        vec4(pi, 1)
    );
}
